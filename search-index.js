var searchIndex = {};
searchIndex["coaster"] = {"doc":"Provides a simple and unified API to run fast and highly parallel computations on different devices such as CPUs and GPUs, accross different computation languages such as OpenCL and CUDA and allows you to swap your backend on run-time.","items":[[0,"backend","coaster","Provides the interface for running parallel computations on one ore many devices.",null,null],[3,"Backend","coaster::backend","Defines the main and highest struct of Coaster.",null,null],[3,"BackendConfig","","Provides Backend Configuration.",null,null],[8,"IBackend","","Describes a Backend.",null,null],[16,"F","","Represents the Framework of a Backend.",0,null],[10,"device","","Returns the backend device.",0,null],[11,"default","","Try to create a default backend.",0,{"inputs":[],"output":{"generics":["backend","error"],"name":"result"}}],[11,"synchronize","","Synchronize backend.",0,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"backend"}}],[11,"new","","Initialize a new native Backend from a BackendConfig.",1,{"inputs":[{"name":"backendconfig"}],"output":{"generics":["backend","error"],"name":"result"}}],[11,"hardwares","","Returns the available hardware.",1,null],[11,"framework","","Returns the backend framework.",1,{"inputs":[{"name":"self"}],"output":{"name":"box"}}],[11,"device","","Returns the backend device.",1,null],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"backendconfig"}}],[11,"new","","Creates a new BackendConfig.",2,null],[0,"device","coaster","Provides a representation for one or many ready to use hardwares.",null,null],[4,"Error","coaster::device","Defines a generic set of Memory Errors.",null,null],[13,"NoMemorySyncRoute","","No route found for memory transfer between devices",3,null],[13,"MemorySyncError","","Framework error at memory synchronization.",3,null],[13,"MemoryAllocationError","","Framework error at memory allocation.",3,null],[13,"Native","","Failures related to the Native framework implementation.",3,null],[13,"OpenCL","","Failures related to the OpenCL framework implementation.",3,null],[13,"Cuda","","Failures related to the Cuda framework implementation.",3,null],[8,"IMemory","","Marker trait for backing memory.",null,null],[8,"IDevice","","Specifies Hardware behavior across frameworks.",null,null],[16,"H","","The Hardware representation for this Device.",4,null],[16,"M","","The Memory representation for this Device.",4,null],[10,"id","","Returns the unique identifier of the Device.",4,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[10,"hardwares","","Returns the hardwares, which define the Device.",4,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[10,"alloc_memory","","Allocate memory on the Device.",4,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["error"],"name":"result"}}],[8,"MemorySync","","This trait should be implemented for `Device`. Use of `Any` everywhere is ugly, but it looks like there is no other way to do it if we want to extract CUDA stuff into its own crate completely, so that base crate knows nothing about it at all.",null,null],[10,"sync_in","","FIXME",5,{"inputs":[{"name":"self"},{"name":"any"},{"name":"any"},{"name":"any"}],"output":{"generics":["error"],"name":"result"}}],[10,"sync_out","","FIXME",5,{"inputs":[{"name":"self"},{"name":"any"},{"name":"any"},{"name":"any"}],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",3,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",3,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"from","","",3,{"inputs":[{"name":"nativeerror"}],"output":{"name":"error"}}],[11,"from","","",3,{"inputs":[{"name":"openclerror"}],"output":{"name":"error"}}],[11,"from","","",3,{"inputs":[{"name":"cudaerror"}],"output":{"name":"error"}}],[0,"hardware","coaster","Provides a representation for a collection of available compute units e.g. CPUs or GPUs.",null,null],[4,"HardwareType","coaster::hardware","Specifies the available Hardware types.",null,null],[13,"CPU","","CPU devices",6,null],[13,"GPU","","GPU devices",6,null],[13,"ACCELERATOR","","Hardware Accelerator devices",6,null],[13,"OTHER","","Used for anything else",6,null],[8,"IHardware","","Specifies Hardware behavior accross frameworks.",null,null],[10,"id","","Returns the ID of the Hardware",7,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[10,"name","","Returns the name of the Hardware",7,{"inputs":[{"name":"self"}],"output":{"generics":["string"],"name":"option"}}],[10,"set_name","","Defines the name of the Hardware",7,{"inputs":[{"name":"self"},{"generics":["string"],"name":"option"}],"output":{"name":"self"}}],[10,"hardware_type","","Returns the device_type of the Hardware",7,{"inputs":[{"name":"self"}],"output":{"generics":["hardwaretype"],"name":"option"}}],[10,"set_hardware_type","","Defines the hardware_type of the Hardware",7,{"inputs":[{"name":"self"},{"generics":["hardwaretype"],"name":"option"}],"output":{"name":"self"}}],[10,"compute_units","","Returns the compute_units of the Hardware",7,{"inputs":[{"name":"self"}],"output":{"generics":["isize"],"name":"option"}}],[10,"set_compute_units","","Defines the compute_units of the Hardware",7,{"inputs":[{"name":"self"},{"generics":["isize"],"name":"option"}],"output":{"name":"self"}}],[10,"build","","Build an inmutable Hardware",7,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"hardwaretype"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"hardwaretype"}],"output":{"name":"bool"}}],[11,"hash","","",6,null],[0,"framework","coaster","Provides the generic functionality of a hardware supporting frameworks such as native CPU, OpenCL, CUDA, etc.. [hardware]: ../hardware/index.html",null,null],[4,"Error","coaster::framework","Defines a generic set of Framework Errors.",null,null],[13,"OpenCL","","Failures related to the OpenCL framework implementation.",8,null],[13,"Cuda","","Failures related to the Cuda framework implementation.",8,null],[13,"Implementation","","Failure related to the Coaster implementation of a specific Framework.",8,null],[8,"IFramework","","Defines a Framework.",null,null],[16,"H","","The Hardware representation for this Framework.",9,null],[16,"D","","The Device representation for this Framework.",9,null],[16,"B","","The Binary representation for this Framework.",9,null],[10,"ID","","Defines the Framework by a Name.",9,{"inputs":[],"output":{"name":"str"}}],[10,"new","","Initializes a new Framework.",9,{"inputs":[],"output":{"name":"self"}}],[10,"load_hardwares","","Initializes all the available hardwares.",9,{"inputs":[],"output":{"generics":["vec","error"],"name":"result"}}],[10,"hardwares","","Returns the cached and available hardwares.",9,null],[10,"binary","","Returns the initialized binary.",9,null],[10,"new_device","","Initializes a new Device from the provided hardwares.",9,null],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",8,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",8,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"from","","",8,{"inputs":[{"name":"openclerror"}],"output":{"name":"error"}}],[11,"from","","",8,{"inputs":[{"name":"cudaerror"}],"output":{"name":"error"}}],[0,"frameworks","coaster","Exposes the specific Framework implementations.",null,null],[0,"native","coaster::frameworks","Provides informations about the software system, such as OpenCL, CUDA, that contains the set of components to support [hardwares][hardware] with kernel execution. [hardware]: ../hardware/index.html",null,null],[3,"Native","coaster::frameworks::native","Provides the Native framework.",null,null],[4,"Error","","Defines the Native Error.",null,null],[13,"Memory","","Failure related to allocation, syncing memory",10,null],[5,"allocate_boxed_slice","","Traditional allocation via creation of a filled Vec.",null,{"inputs":[{"name":"usize"}],"output":{"name":"box"}}],[0,"device","","Provides a hardware aka. the host CPU.",null,null],[3,"Cpu","coaster::frameworks::native::device","Defines the host CPU Hardware.",null,null],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"self"}],"output":{"name":"cpu"}}],[11,"new","","Initializes a new OpenCL hardware.",11,{"inputs":[{"generics":["hardware"],"name":"vec"}],"output":{"name":"cpu"}}],[11,"id","","",11,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[11,"hardwares","","",11,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"alloc_memory","","",11,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["flatbox","deviceerror"],"name":"result"}}],[11,"sync_in","","",11,{"inputs":[{"name":"self"},{"name":"any"},{"name":"any"},{"name":"any"}],"output":{"generics":["deviceerror"],"name":"result"}}],[11,"sync_out","","",11,{"inputs":[{"name":"self"},{"name":"any"},{"name":"any"},{"name":"any"}],"output":{"generics":["deviceerror"],"name":"result"}}],[11,"eq","","",11,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"hash","","",11,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[0,"flatbox","coaster::frameworks::native","Provides a Box without any knowledge of its underlying type.",null,null],[3,"FlatBox","coaster::frameworks::native::flatbox","A Box without any knowledge of its underlying type.",null,null],[11,"from_box","","Create FlatBox from Box, consuming it.",12,{"inputs":[{"name":"box"}],"output":{"name":"flatbox"}}],[11,"as_slice","","Access memory as slice.",12,null],[11,"as_mut_slice","","Access memory as mutable slice.",12,null],[11,"byte_size","","Returns memory size of the Flatbox.",12,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"drop","","",12,{"inputs":[{"name":"self"}],"output":null}],[11,"fmt","","",12,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"hardware","coaster::frameworks::native","Provides a hardware aka. the host CPU.",null,null],[3,"Hardware","coaster::frameworks::native::hardware","Defines the host CPU Hardware.",null,null],[11,"fmt","","",13,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",13,{"inputs":[{"name":"self"}],"output":{"name":"hardware"}}],[11,"default","","",13,{"inputs":[],"output":{"name":"self"}}],[11,"new","","Initializes a new OpenCL hardware.",13,{"inputs":[{"name":"isize"}],"output":{"name":"hardware"}}],[11,"id","","",13,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[11,"name","","",13,{"inputs":[{"name":"self"}],"output":{"generics":["string"],"name":"option"}}],[11,"set_name","","",13,{"inputs":[{"name":"self"},{"generics":["string"],"name":"option"}],"output":{"name":"self"}}],[11,"hardware_type","","",13,{"inputs":[{"name":"self"}],"output":{"generics":["hardwaretype"],"name":"option"}}],[11,"set_hardware_type","","",13,{"inputs":[{"name":"self"},{"generics":["hardwaretype"],"name":"option"}],"output":{"name":"self"}}],[11,"compute_units","","",13,{"inputs":[{"name":"self"}],"output":{"generics":["isize"],"name":"option"}}],[11,"set_compute_units","","",13,{"inputs":[{"name":"self"},{"generics":["isize"],"name":"option"}],"output":{"name":"self"}}],[11,"build","","",13,{"inputs":[{"name":"self"}],"output":{"name":"hardware"}}],[0,"function","coaster::frameworks::native","Provides a operation on native CPU.",null,null],[3,"Function","coaster::frameworks::native::function","Defines a host CPU operation.",null,null],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",14,{"inputs":[{"name":"self"}],"output":{"name":"function"}}],[11,"new","","Initializes a native CPU hardware.",14,{"inputs":[],"output":{"name":"function"}}],[0,"binary","coaster::frameworks::native","Provides a binary on native CPU.",null,null],[3,"Binary","coaster::frameworks::native::binary","Defines a host CPU binary.",null,null],[11,"fmt","","",15,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"self"}],"output":{"name":"binary"}}],[11,"new","","Initializes the native CPU binary.",15,{"inputs":[],"output":{"name":"binary"}}],[11,"fmt","coaster::frameworks::native","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",10,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",10,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[8,"INative","","Provides the Native framework trait for explicit Backend behaviour.",null,null],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",16,{"inputs":[{"name":"self"}],"output":{"name":"native"}}],[11,"ID","","",16,{"inputs":[],"output":{"name":"str"}}],[11,"new","","",16,{"inputs":[],"output":{"name":"native"}}],[11,"load_hardwares","","",16,{"inputs":[],"output":{"generics":["vec","error"],"name":"result"}}],[11,"hardwares","","",16,null],[11,"binary","","",16,{"inputs":[{"name":"self"}],"output":{"name":"binary"}}],[11,"new_device","","",16,null],[11,"device","coaster::backend","",1,{"inputs":[{"name":"self"}],"output":{"name":"cpu"}}],[0,"opencl","coaster::frameworks","Provides informations about the software system, such as OpenCL, CUDA, that contains the set of components to support [hardwares][hardware] with kernel execution. [hardware]: ../hardware/index.html",null,null],[3,"API","coaster::frameworks::opencl","Defines the OpenCL API.",null,null],[3,"OpenCL","","Provides the OpenCL Framework.",null,null],[4,"Error","","Defines OpenCL errors.",null,null],[13,"InvalidPlatform","","Failure with provided platform.",17,null],[13,"InvalidDevice","","Failure with provided device param.",17,null],[13,"InvalidDeviceType","","Failure with provided platform.",17,null],[13,"InvalidContext","","Failure with provided context.",17,null],[13,"InvalidMemObject","","Failure with provided memory object.",17,null],[13,"InvalidCommandQueue","","Failure with provided command queue.",17,null],[13,"InvalidEventWaitList","","Failure with provided event list.",17,null],[13,"InvalidValue","","Failure with provided param(s).",17,null],[13,"InvalidProperty","","Failure with provided property param.",17,null],[13,"InvalidOperation","","Failure with provided operation param.",17,null],[13,"InvalidBufferSize","","Failure with provided buffer size.",17,null],[13,"InvalidHostPtr","","Failure with provided host pointer.",17,null],[13,"InvalidWorkDimension","","Failure with provided work dimensions",17,null],[13,"InvalidWorkItemSize","","Failure with provided work item size",17,null],[13,"InvalidWorkGroupSize","","Failure with provided work group size",17,null],[13,"InvalidGlobalOffset","","Failure with provided global offset",17,null],[13,"InvalidKernel","","Failure with provided kernel",17,null],[13,"InvalidKernelArgs","","Failure with provided kernel arguments",17,null],[13,"InvalidQueueProperties","","Failure with provided properties for the device.",17,null],[13,"DeviceNotFound","","Failure with device availability.",17,null],[13,"DeviceNotAvailable","","Failure with device availability.",17,null],[13,"MemObjectAllocationFailure","","Failure to allocate memory.",17,null],[13,"MisalignedSubBufferOffset","","Failure with sub buffer offset.",17,null],[13,"ExecStatusErrorForEventsInWaitList","","Failure with events in wait list.",17,null],[13,"OutOfResources","","Failure to allocate resources on the device.",17,null],[13,"OutOfHostMemory","","Failure to allocate resources on the host.",17,null],[13,"Other","","Failure not closer defined.",17,null],[0,"device","","Provides a Rust wrapper around OpenCL's device.",null,null],[3,"Version","coaster::frameworks::opencl::device","Defines a OpenCL Version.",null,null],[3,"Device","","Defines a OpenCL Device.",null,null],[3,"DeviceInfo","","Defines a generic DeviceInfo container.",null,null],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"version"}}],[11,"eq","","",18,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"cmp","","",18,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",18,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",19,{"inputs":[{"name":"self"},{"name":"device"}],"output":{"name":"bool"}}],[11,"ne","","",19,{"inputs":[{"name":"self"},{"name":"device"}],"output":{"name":"bool"}}],[11,"clone","","",19,{"inputs":[{"name":"self"}],"output":{"name":"device"}}],[11,"default","","",19,{"inputs":[],"output":{"name":"self"}}],[11,"from_isize","","Initializes a new OpenCL device.",19,{"inputs":[{"name":"isize"}],"output":{"name":"device"}}],[11,"from_c","","Initializes a new OpenCL device from its C type.",19,null],[11,"id_c","","Returns the id as its C type.",19,null],[11,"load_name","","Loads the name of the device via a foreign OpenCL call.",19,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"load_device_type","","Loads the device type via a foreign OpenCL call.",19,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"load_compute_units","","Loads the compute units of the device via a foreign OpenCL call.",19,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"load_version","","Loads the OpenCL version this device supports via a foreign OpenCL call.",19,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"load_vendor","","Loads the OpenCL version this device supports via a foreign OpenCL call.",19,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"id","","",19,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[11,"name","","",19,{"inputs":[{"name":"self"}],"output":{"generics":["string"],"name":"option"}}],[11,"set_name","","",19,{"inputs":[{"name":"self"},{"generics":["string"],"name":"option"}],"output":{"name":"self"}}],[11,"hardware_type","","",19,{"inputs":[{"name":"self"}],"output":{"generics":["hardwaretype"],"name":"option"}}],[11,"set_hardware_type","","",19,{"inputs":[{"name":"self"},{"generics":["hardwaretype"],"name":"option"}],"output":{"name":"self"}}],[11,"compute_units","","",19,{"inputs":[{"name":"self"}],"output":{"generics":["isize"],"name":"option"}}],[11,"set_compute_units","","",19,{"inputs":[{"name":"self"},{"generics":["isize"],"name":"option"}],"output":{"name":"self"}}],[11,"build","","",19,{"inputs":[{"name":"self"}],"output":{"name":"device"}}],[11,"fmt","","",20,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",20,{"inputs":[{"name":"self"}],"output":{"name":"deviceinfo"}}],[11,"new","","Initializes a new Device Info",20,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"name":"deviceinfo"}}],[11,"to_string","","",20,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"to_device_type","","",20,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"to_isize","","",20,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[11,"to_version","","",20,{"inputs":[{"name":"self"}],"output":{"name":"version"}}],[0,"platform","coaster::frameworks::opencl","Provides a Rust wrapper around OpenCL's platform.",null,null],[3,"Platform","coaster::frameworks::opencl::platform","Defines a OpenCL Platform.",null,null],[11,"fmt","","",21,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",21,{"inputs":[{"name":"self"}],"output":{"name":"platform"}}],[11,"eq","","",21,{"inputs":[{"name":"self"},{"name":"platform"}],"output":{"name":"bool"}}],[11,"ne","","",21,{"inputs":[{"name":"self"},{"name":"platform"}],"output":{"name":"bool"}}],[11,"from_isize","","Initializes a new OpenCL platform.",21,{"inputs":[{"name":"isize"}],"output":{"name":"platform"}}],[11,"from_c","","Initializes a new OpenCL platform from its C type.",21,null],[11,"id","","Returns the id as isize.",21,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[11,"id_c","","Returns the id as its C type.",21,null],[0,"context","coaster::frameworks::opencl","Provides a Rust wrapper around OpenCL's context.",null,null],[3,"Context","coaster::frameworks::opencl::context","Defines a OpenCL Context.",null,null],[4,"ContextProperties","","The individual properties for `ContextInfo::Properties`",null,null],[13,"Platform","","Identifies a context's associated platform.",22,null],[13,"InteropUserSync","","Does the user need to sync between frameworks manually (OpenCL 2.0 and later)",22,null],[4,"ContextInfoQuery","","OpenCL context info constants, these ones are for the Query",null,null],[13,"ReferenceCount","","Number of references to the context currently held.",23,null],[13,"NumDevices","","Number of devices in the context.",23,null],[13,"Properties","","The properties the context was configured with.",23,null],[13,"Devices","","The devices (IDs) in the context.",23,null],[4,"ContextInfo","","OpenCL context info types. Each variant is returned from the same function, `get_context_info`.",null,null],[13,"ReferenceCount","","Number of references to the context currently held.",24,null],[13,"NumDevices","","Number of devices in the context.",24,null],[13,"Properties","","The properties the context was configured with.",24,null],[13,"Devices","","The devices (IDs) in the context.",24,null],[11,"fmt","","",25,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",25,{"inputs":[{"name":"self"}],"output":{"name":"context"}}],[11,"eq","","",22,{"inputs":[{"name":"self"},{"name":"contextproperties"}],"output":{"name":"bool"}}],[11,"ne","","",22,{"inputs":[{"name":"self"},{"name":"contextproperties"}],"output":{"name":"bool"}}],[11,"fmt","","",22,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",22,{"inputs":[{"name":"self"}],"output":{"name":"contextproperties"}}],[11,"eq","","",23,{"inputs":[{"name":"self"},{"name":"contextinfoquery"}],"output":{"name":"bool"}}],[11,"fmt","","",23,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"contextinfoquery"}}],[11,"clone","","",24,{"inputs":[{"name":"self"}],"output":{"name":"contextinfo"}}],[11,"fmt","","",24,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Initializes a new OpenCL platform.",25,{"inputs":[{"generics":["device"],"name":"vec"}],"output":{"generics":["context","error"],"name":"result"}}],[11,"from_c","","Initializes a new OpenCL platform from its C type.",25,null],[11,"queue","","Returns Queue for first device.",25,{"inputs":[{"name":"self"}],"output":{"generics":["queue"],"name":"option"}}],[11,"queue_mut","","Returns mutable Queue for first device and creates it if it does not exist yet.",25,{"inputs":[{"name":"self"}],"output":{"name":"queue"}}],[11,"get_context_info","","Get certain parameters of the context, defined by `ContextInfoQuery`.",25,{"inputs":[{"name":"self"},{"name":"contextinfoquery"}],"output":{"generics":["contextinfo","error"],"name":"result"}}],[11,"id","","Returns the id as isize.",25,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[11,"id_c","","Returns the id as its C type.",25,null],[11,"id","","",25,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[11,"hardwares","","",25,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"alloc_memory","","",25,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"generics":["memory","deviceerror"],"name":"result"}}],[11,"sync_in","","",25,{"inputs":[{"name":"self"},{"name":"any"},{"name":"any"},{"name":"any"}],"output":{"generics":["deviceerror"],"name":"result"}}],[11,"sync_out","","",25,{"inputs":[{"name":"self"},{"name":"any"},{"name":"any"},{"name":"any"}],"output":{"generics":["deviceerror"],"name":"result"}}],[11,"eq","","",25,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"hash","","",25,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[0,"memory","coaster::frameworks::opencl","",null,null],[3,"Memory","coaster::frameworks::opencl::memory","Holds a OpenCL memory id and manages its deallocation",null,null],[3,"MemoryFlags","","",null,null],[17,"MEM_READ_WRITE","","",null,null],[17,"MEM_WRITE_ONLY","","",null,null],[17,"MEM_READ_ONLY","","",null,null],[17,"MEM_USE_HOST_PTR","","",null,null],[17,"MEM_ALLOC_HOST_PTR","","",null,null],[17,"MEM_COPY_HOST_PTR","","",null,null],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"drop","","",26,{"inputs":[{"name":"self"}],"output":null}],[11,"eq","","",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":{"name":"bool"}}],[11,"ne","","",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":{"name":"bool"}}],[11,"clone","","",27,{"inputs":[{"name":"self"}],"output":{"name":"memoryflags"}}],[11,"partial_cmp","","",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":{"name":"bool"}}],[11,"le","","",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":{"name":"bool"}}],[11,"gt","","",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":{"name":"bool"}}],[11,"ge","","",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":{"name":"bool"}}],[11,"cmp","","",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":{"name":"ordering"}}],[11,"hash","","",27,null],[11,"fmt","","",27,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",27,{"inputs":[],"output":{"name":"memoryflags"}}],[11,"all","","Returns the set containing all flags.",27,{"inputs":[],"output":{"name":"memoryflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",27,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",27,{"inputs":[{"name":"u64"}],"output":{"generics":["memoryflags"],"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",27,{"inputs":[{"name":"u64"}],"output":{"name":"memoryflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",27,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",27,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":{"name":"memoryflags"}}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":{"name":"memoryflags"}}],[11,"bitand","","Returns the intersection between the two sets of flags.",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":{"name":"memoryflags"}}],[11,"sub","","Returns the set difference of the two sets of flags.",27,{"inputs":[{"name":"self"},{"name":"memoryflags"}],"output":{"name":"memoryflags"}}],[11,"not","","Returns the complement of this set of flags.",27,{"inputs":[{"name":"self"}],"output":{"name":"memoryflags"}}],[11,"from_iter","","",27,{"inputs":[{"name":"t"}],"output":{"name":"memoryflags"}}],[11,"default","","",27,{"inputs":[],"output":{"name":"memoryflags"}}],[11,"new","","",26,{"inputs":[{"name":"context"},{"name":"usize"}],"output":{"generics":["memory","error"],"name":"result"}}],[11,"id_c","","",26,null],[11,"from_c","","",26,null],[0,"queue","coaster::frameworks::opencl","Provides a Rust wrapper around OpenCL's command queue.",null,null],[3,"Queue","coaster::frameworks::opencl::queue","Defines a OpenCL Queue.",null,null],[3,"QueueFlags","","",null,null],[17,"CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE","","",null,null],[17,"CL_QUEUE_PROFILING_ENABLE","","",null,null],[11,"fmt","","",28,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",28,{"inputs":[{"name":"self"}],"output":{"name":"queue"}}],[11,"new","","Create a new command queue for the provided `context` and `device`.",28,{"inputs":[{"name":"context"},{"name":"device"},{"generics":["queueflags"],"name":"option"}],"output":{"generics":["queue","error"],"name":"result"}}],[11,"from_isize","","Initializes a new OpenCL command queue.",28,{"inputs":[{"name":"isize"}],"output":{"name":"queue"}}],[11,"from_c","","Initializes a new OpenCL command queue from its C type.",28,null],[11,"id","","Returns the id as isize.",28,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[11,"id_c","","Returns the id as its C type.",28,null],[11,"enqueue_kernel","","Enqueue a Opencl program/kernel.",28,null],[11,"eq","","",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":{"name":"bool"}}],[11,"ne","","",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":{"name":"bool"}}],[11,"clone","","",29,{"inputs":[{"name":"self"}],"output":{"name":"queueflags"}}],[11,"partial_cmp","","",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"lt","","",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":{"name":"bool"}}],[11,"le","","",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":{"name":"bool"}}],[11,"gt","","",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":{"name":"bool"}}],[11,"ge","","",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":{"name":"bool"}}],[11,"cmp","","",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":{"name":"ordering"}}],[11,"hash","","",29,null],[11,"fmt","","",29,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",29,{"inputs":[],"output":{"name":"queueflags"}}],[11,"all","","Returns the set containing all flags.",29,{"inputs":[],"output":{"name":"queueflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",29,{"inputs":[{"name":"self"}],"output":{"name":"u64"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",29,{"inputs":[{"name":"u64"}],"output":{"generics":["queueflags"],"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",29,{"inputs":[{"name":"u64"}],"output":{"name":"queueflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",29,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",29,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":{"name":"queueflags"}}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":{"name":"queueflags"}}],[11,"bitand","","Returns the intersection between the two sets of flags.",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":{"name":"queueflags"}}],[11,"sub","","Returns the set difference of the two sets of flags.",29,{"inputs":[{"name":"self"},{"name":"queueflags"}],"output":{"name":"queueflags"}}],[11,"not","","Returns the complement of this set of flags.",29,{"inputs":[{"name":"self"}],"output":{"name":"queueflags"}}],[11,"from_iter","","",29,{"inputs":[{"name":"t"}],"output":{"name":"queueflags"}}],[11,"default","","",29,{"inputs":[],"output":{"name":"queueflags"}}],[0,"event","coaster::frameworks::opencl","Provides a Rust wrapper around OpenCL's events.",null,null],[3,"Event","coaster::frameworks::opencl::event","Defines a OpenCL Event;",null,null],[11,"fmt","","",30,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",30,{"inputs":[{"name":"self"}],"output":{"name":"event"}}],[11,"from_c","","Initializes a new OpenCL even from its C type.",30,null],[11,"id_c","","Returns the id as its C type.",30,null],[0,"kernel","coaster::frameworks::opencl","Provides a Rust wrapper around OpenCL's Kernel.",null,null],[3,"Kernel","coaster::frameworks::opencl::kernel","Defines a OpenCL Kernel.",null,null],[11,"fmt","","",31,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",31,{"inputs":[{"name":"self"}],"output":{"name":"kernel"}}],[11,"from_isize","","Initializes a new OpenCL device.",31,{"inputs":[{"name":"isize"}],"output":{"name":"kernel"}}],[11,"from_c","","Initializes a new OpenCL device from its C type.",31,null],[11,"id_c","","Returns the id as its C type.",31,null],[0,"program","coaster::frameworks::opencl","Provides a Rust wrapper around OpenCL's Program.",null,null],[3,"Program","coaster::frameworks::opencl::program","Defines a OpenCL Program.",null,null],[11,"fmt","","",32,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",32,{"inputs":[{"name":"self"}],"output":{"name":"program"}}],[11,"from_isize","","Initializes a new OpenCL device.",32,{"inputs":[{"name":"isize"}],"output":{"name":"program"}}],[11,"from_c","","Initializes a new OpenCL device from its C type.",32,null],[11,"id_c","","Returns the id as its C type.",32,null],[11,"fmt","coaster::frameworks::opencl","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",17,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"eq","","",17,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"ne","","",17,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"fmt","","",17,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",17,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",17,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"create_context","","Creates a OpenCL context.",33,null],[11,"get_context_info","","Gets info about one of the available properties of an OpenCL context.",33,null],[11,"load_devices","","Returns fully initialized devices for a specific platform.",33,{"inputs":[{"name":"platform"}],"output":{"generics":["vec","error"],"name":"result"}}],[11,"load_device_list","","Returns a list of available devices for the provided platform.",33,{"inputs":[{"name":"platform"}],"output":{"generics":["vec","error"],"name":"result"}}],[11,"load_device_info","","Returns the requested DeviceInfo for the provided device.",33,{"inputs":[{"name":"device"},{"name":"u32"}],"output":{"generics":["deviceinfo","error"],"name":"result"}}],[11,"create_buffer","","Allocates memory on the OpenCL device.",33,{"inputs":[{"name":"context"},{"name":"memoryflags"},{"name":"usize"},{"name":"option"}],"output":{"generics":["memory","error"],"name":"result"}}],[11,"release_memory","","Releases allocated memory from the OpenCL device.",33,{"inputs":[{"name":"memory"}],"output":{"generics":["error"],"name":"result"}}],[11,"read_from_memory","","Reads from a OpenCL memory object to the host memory.",33,null],[11,"write_to_memory","","Write to a OpenCL memory object from host memory.",33,null],[11,"load_platforms","","Returns a list of available platforms.",33,{"inputs":[],"output":{"generics":["vec","error"],"name":"result"}}],[11,"create_queue","","Returns a command queue for a specified context and device.",33,{"inputs":[{"name":"context"},{"name":"device"},{"name":"queueflags"}],"output":{"generics":["queue","error"],"name":"result"}}],[11,"release_queue","","Releases command queue from the OpenCL device.",33,{"inputs":[{"name":"queue"}],"output":{"generics":["error"],"name":"result"}}],[11,"enqueue_kernel","","Enqueue program in a command queue.",33,null],[11,"fmt","","",33,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",33,{"inputs":[{"name":"self"}],"output":{"name":"api"}}],[8,"IOpenCL","","Provides the OpenCL framework trait for explicit Backend behaviour.",null,null],[11,"fmt","","",34,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",34,{"inputs":[{"name":"self"}],"output":{"name":"opencl"}}],[11,"ID","","",34,{"inputs":[],"output":{"name":"str"}}],[11,"new","","",34,{"inputs":[],"output":{"name":"opencl"}}],[11,"load_hardwares","","",34,{"inputs":[],"output":{"generics":["vec","error"],"name":"result"}}],[11,"hardwares","","",34,null],[11,"binary","","",34,null],[11,"new_device","","Creates a new OpenCL context over one or many devices ready for computation.",34,null],[11,"device","coaster::backend","",1,{"inputs":[{"name":"self"}],"output":{"name":"context"}}],[0,"cuda","coaster::frameworks","Provides informations about the software system, such as Cuda, CUDA, that contains the set of components to support [hardwares][hardware] with kernel execution. [hardware]: ../hardware/index.html",null,null],[3,"Driver","coaster::frameworks::cuda","Defines the Cuda API.",null,null],[3,"Cuda","","Provides the Cuda Framework.",null,null],[4,"DriverError","","Defines OpenCL errors.",null,null],[13,"InvalidValue","","Failure with provided value.",35,null],[13,"OutOfMemory","","Failure with memory allocation.",35,null],[13,"NotInitialized","","Failure with Cuda initialization.",35,null],[13,"Deinitialized","","Failure with Cuda initialization.",35,null],[13,"ProfilerDisabled","","Failure with Profiler.",35,null],[13,"ProfilerNotInitialized","","Failure with Profiler.",35,null],[13,"ProfilerAlreadyStarted","","Failure with Profiler.",35,null],[13,"ProfilerAlreadyStopped","","Failure with Profiler.",35,null],[13,"NoDevice","","Failure with Cuda devices.",35,null],[13,"InvalidDevice","","Failure with provided Cuda device.",35,null],[13,"InvalidImage","","Failure with provided Cuda image.",35,null],[13,"InvalidContext","","Failure with provided Cuda context.",35,null],[13,"ContextAlreadyCurrent","","Failure with provided Cuda context.",35,null],[13,"MapFailed","","Failure",35,null],[13,"UnmapFailed","","Failure",35,null],[13,"ArrayIsMapped","","Failure",35,null],[13,"AlreadyMapped","","Failure",35,null],[13,"NoBinaryForGpu","","Failure with binary.",35,null],[13,"AlreadyAquired","","Failure",35,null],[13,"NotMapped","","Failure",35,null],[13,"NotMappedAsArray","","Failure",35,null],[13,"NotMappedAsPointer","","Failure",35,null],[13,"EccUncorrectable","","Failure",35,null],[13,"UnsupportedLimit","","Failure",35,null],[13,"ContextAlreadyInUse","","Failure with context.",35,null],[13,"PeerAccessUnsupported","","Failure",35,null],[13,"InvalidPtx","","Failure with provided PTX.",35,null],[13,"InvalidGraphicsContent","","Failure",35,null],[13,"InvalidSource","","Failure",35,null],[13,"FileNotFound","","Failure",35,null],[13,"SharedObjectSymbolNotFound","","Failure",35,null],[13,"SharedObjectInitFailed","","Failure",35,null],[13,"OperatingSystem","","Failure",35,null],[13,"InvalidHandle","","Failure",35,null],[13,"NotFound","","Failure",35,null],[13,"NotReady","","Failure",35,null],[13,"IllegalAddress","","Failure",35,null],[13,"LaunchOutOfResources","","Failure",35,null],[13,"LaunchTimeout","","Failure",35,null],[13,"LauncIncompatibleTexturing","","Failure",35,null],[13,"PeerAccessAlreadyEnabled","","Failure",35,null],[13,"PeerAccessNotEnabled","","Failure",35,null],[13,"PrimaryContextActive","","Failure",35,null],[13,"ContextIsDestroyed","","Failure",35,null],[13,"Assert","","Failure",35,null],[13,"TooManyPeers","","Failure",35,null],[13,"HostMemoryAlreadyRegistered","","Failure",35,null],[13,"HostMemoryNotRegistered","","Failure",35,null],[13,"HardwareStackError","","Failure",35,null],[13,"IllegalInstruction","","Failure",35,null],[13,"MisalignedAddress","","Failure",35,null],[13,"InvalidAddressSpace","","Failure",35,null],[13,"InvalidPc","","Failure",35,null],[13,"LaunchFailed","","Failure",35,null],[13,"NotPermitted","","Failure",35,null],[13,"NotSupported","","Failure",35,null],[13,"Unknown","","Failure",35,null],[0,"device","","Provides a Rust wrapper around Cuda's device.",null,null],[3,"Device","coaster::frameworks::cuda::device","Defines a Cuda Device.",null,null],[3,"DeviceInfo","","Defines a generic DeviceInfo container.",null,null],[11,"fmt","","",36,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",36,{"inputs":[{"name":"self"}],"output":{"name":"device"}}],[11,"default","","",36,{"inputs":[],"output":{"name":"self"}}],[11,"from_isize","","Initializes a new Cuda device.",36,{"inputs":[{"name":"isize"}],"output":{"name":"device"}}],[11,"from_c","","Initializes a new Cuda device from its C type.",36,{"inputs":[{"name":"c_int"}],"output":{"name":"device"}}],[11,"id_c","","Returns the id as its C type.",36,{"inputs":[{"name":"self"}],"output":{"name":"c_int"}}],[11,"load_name","","Loads the name of the device via a foreign Cuda call.",36,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"load_device_type","","Loads the device type via a foreign Cuda call.",36,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"load_compute_units","","Loads the compute units of the device via a foreign Cuda call.",36,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"id","","",36,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[11,"name","","",36,{"inputs":[{"name":"self"}],"output":{"generics":["string"],"name":"option"}}],[11,"set_name","","",36,{"inputs":[{"name":"self"},{"generics":["string"],"name":"option"}],"output":{"name":"self"}}],[11,"hardware_type","","",36,{"inputs":[{"name":"self"}],"output":{"generics":["hardwaretype"],"name":"option"}}],[11,"set_hardware_type","","",36,{"inputs":[{"name":"self"},{"generics":["hardwaretype"],"name":"option"}],"output":{"name":"self"}}],[11,"compute_units","","",36,{"inputs":[{"name":"self"}],"output":{"generics":["isize"],"name":"option"}}],[11,"set_compute_units","","",36,{"inputs":[{"name":"self"},{"generics":["isize"],"name":"option"}],"output":{"name":"self"}}],[11,"build","","",36,{"inputs":[{"name":"self"}],"output":{"name":"device"}}],[11,"eq","","",36,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"fmt","","",37,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",37,{"inputs":[{"name":"self"}],"output":{"name":"deviceinfo"}}],[11,"new","","Initializes a new Device Info",37,{"inputs":[{"generics":["u8"],"name":"vec"}],"output":{"name":"deviceinfo"}}],[11,"to_string","","",37,{"inputs":[{"name":"self"}],"output":{"name":"string"}}],[11,"to_isize","","",37,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[0,"context","coaster::frameworks::cuda","Provides a Rust wrapper around Cuda's context.",null,null],[3,"Context","coaster::frameworks::cuda::context","Defines a Cuda Context.",null,null],[11,"fmt","","",38,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",38,{"inputs":[{"name":"self"}],"output":{"name":"context"}}],[11,"drop","","",38,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","Initializes a new Cuda context.",38,{"inputs":[{"name":"device"}],"output":{"generics":["context","drivererror"],"name":"result"}}],[11,"from_c","","Initializes a new Cuda platform from its C type.",38,null],[11,"id","","Returns the id as isize.",38,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[11,"id_c","","Returns the id as its C type.",38,null],[11,"synchronize","","Synchronize this Context.",38,{"inputs":[{"name":"self"}],"output":{"generics":["drivererror"],"name":"result"}}],[11,"id","","",38,{"inputs":[{"name":"self"}],"output":{"name":"isize"}}],[11,"hardwares","","",38,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"alloc_memory","","",38,{"inputs":[{"name":"self"},{"name":"size_t"}],"output":{"generics":["memory","deviceerror"],"name":"result"}}],[11,"sync_in","","",38,{"inputs":[{"name":"self"},{"name":"any"},{"name":"any"},{"name":"any"}],"output":{"generics":["deviceerror"],"name":"result"}}],[11,"sync_out","","",38,{"inputs":[{"name":"self"},{"name":"any"},{"name":"any"},{"name":"any"}],"output":{"generics":["deviceerror"],"name":"result"}}],[11,"eq","","",38,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"bool"}}],[11,"hash","","",38,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[0,"function","coaster::frameworks::cuda","Provides a Rust wrapper around Cuda's Function.",null,null],[3,"Function","coaster::frameworks::cuda::function","Defines a Cuda Function.",null,null],[11,"fmt","","",39,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",39,{"inputs":[{"name":"self"}],"output":{"name":"function"}}],[11,"from_isize","","Initializes a new OpenCL device.",39,{"inputs":[{"name":"isize"}],"output":{"name":"function"}}],[0,"memory","coaster::frameworks::cuda","Provides a Rust wrapper around Cuda's memory.",null,null],[3,"Memory","coaster::frameworks::cuda::memory","Defines a Cuda Memory.",null,null],[11,"fmt","","",40,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"drop","","",40,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","Initializes a new Cuda memory.",40,{"inputs":[{"name":"usize"}],"output":{"generics":["memory","drivererror"],"name":"result"}}],[11,"from_c","","Initializes a new Cuda memory from its C type.",40,{"inputs":[{"name":"c_ulonglong"}],"output":{"name":"memory"}}],[11,"id_c","","Returns the memory id as its C type.",40,{"inputs":[{"name":"self"}],"output":{"name":"c_ulonglong"}}],[0,"module","coaster::frameworks::cuda","Provides a Rust wrapper around Cuda's Module.",null,null],[3,"Module","coaster::frameworks::cuda::module","Defines a Cuda Module.",null,null],[11,"fmt","","",41,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",41,{"inputs":[{"name":"self"}],"output":{"name":"module"}}],[11,"from_isize","","Initializes a new OpenCL device.",41,{"inputs":[{"name":"isize"}],"output":{"name":"module"}}],[11,"fmt","coaster::frameworks::cuda","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",35,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"eq","","",35,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"ne","","",35,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"fmt","","",35,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",35,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",35,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"create_context","","Creates a Cuda context.",42,{"inputs":[{"name":"device"}],"output":{"generics":["error"],"name":"result"}}],[11,"destroy_context","","Removes a created Cuda context from the device.",42,null],[11,"synchronize_context","","Synchronize the CUDA context associated with the current CPU thread.",42,{"inputs":[],"output":{"generics":["error"],"name":"result"}}],[11,"load_devices","","Returns fully initialized devices available through Cuda.",42,{"inputs":[],"output":{"generics":["vec","error"],"name":"result"}}],[11,"load_device_list","","Returns a list of available devices for the provided platform.",42,{"inputs":[],"output":{"generics":["vec","error"],"name":"result"}}],[11,"load_device_info","","Returns the requested DeviceInfo for the provided device.",42,{"inputs":[{"name":"device"},{"name":"cudevice_attribute"}],"output":{"generics":["deviceinfo","error"],"name":"result"}}],[11,"mem_alloc","","Allocates memory on the Cuda device.",42,{"inputs":[{"name":"size_t"}],"output":{"generics":["memory","error"],"name":"result"}}],[11,"mem_free","","Releases allocated memory from the Cuda device.",42,{"inputs":[{"name":"c_ulonglong"}],"output":{"generics":["error"],"name":"result"}}],[11,"mem_cpy_h_to_d","","Copies memory from the Host to the Cuda device.",42,{"inputs":[{"name":"flatbox"},{"name":"memory"}],"output":{"generics":["error"],"name":"result"}}],[11,"mem_cpy_d_to_h","","Copies memory from the Cuda device to the Host.",42,{"inputs":[{"name":"memory"},{"name":"flatbox"}],"output":{"generics":["error"],"name":"result"}}],[11,"init","","Initialize the Cuda Driver API.",42,{"inputs":[],"output":{"generics":["error"],"name":"result"}}],[11,"fmt","","",42,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",42,{"inputs":[{"name":"self"}],"output":{"name":"api"}}],[11,"fmt","","",43,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",43,{"inputs":[{"name":"self"}],"output":{"name":"cuda"}}],[11,"ID","","",43,{"inputs":[],"output":{"name":"str"}}],[11,"new","","",43,{"inputs":[],"output":{"name":"cuda"}}],[11,"load_hardwares","","",43,{"inputs":[],"output":{"generics":["vec","error"],"name":"result"}}],[11,"hardwares","","",43,null],[11,"binary","","",43,null],[11,"new_device","","Creates a new Cuda context for computation.",43,null],[11,"device","coaster::backend","",1,{"inputs":[{"name":"self"}],"output":{"name":"context"}}],[11,"synchronize","","",1,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"result"}}],[0,"tensor","coaster","Provides the functionality for memory management across devices.",null,null],[3,"SharedTensor","coaster::tensor","Container that handles synchronization of [Memory][1] of type `T`. [1]: ../memory/index.html",null,null],[4,"Error","","Errors than can occur when synchronizing memory.",null,null],[13,"DeviceError","","Error caused by operations with device: allocation, memory synchronization, etc.",44,null],[13,"InvalidRemove","","Unable to remove Memory copy from SharedTensor.",44,null],[13,"InvalidShape","","Shape provided for reshaping is not compatible with old shape.",44,null],[13,"CapacityExceeded","","Maximal number of backing memories has been reached.",44,null],[13,"UninitializedMemory","","Memory is requested for reading, but it hasn't been initialized.",44,null],[6,"TensorDesc","","Describes the Descriptor of a SharedTensor.",null,null],[8,"ITensorDesc","","Describes the Descriptor of a Tensor.",null,null],[10,"rank","","Returns the rank of the Tensor.",45,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"size","","Returns the summed up length of all dimensions of the Tensor.",45,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[10,"dims","","Returns the dimensions of the Tensor.",45,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[10,"dims_i32","","Returns the dimensions of the Tensor as Vec.",45,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"vec"}}],[11,"default_stride","","Returns the default stride for an Rust allocated Tensor.",45,{"inputs":[{"name":"self"}],"output":{"generics":["usize"],"name":"vec"}}],[11,"default_stride_i32","","Returns the default stride for a Rust allocated Tensor as i32.",45,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"vec"}}],[8,"IntoTensorDesc","","Describes a conversion into a Tensor Descriptor.",null,null],[10,"into","","Converts the implemented type into a TensorDesc.",46,{"inputs":[{"name":"self"}],"output":{"name":"tensordesc"}}],[11,"rank","","",47,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"size","","",47,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"dims","","",47,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"dims_i32","","",47,{"inputs":[{"name":"self"}],"output":{"generics":["i32"],"name":"vec"}}],[11,"fmt","","",48,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create new Tensor by allocating [Memory][1] on a Device. [1]: ../memory/index.html",48,{"inputs":[{"name":"d"}],"output":{"name":"sharedtensor"}}],[11,"reshape","","Change the shape of the Tensor.",48,{"inputs":[{"name":"self"},{"name":"d"}],"output":{"generics":["error"],"name":"result"}}],[11,"resize","","Change the size and shape of the Tensor.",48,{"inputs":[{"name":"self"},{"name":"d"}],"output":{"generics":["error"],"name":"result"}}],[11,"read","","Get memory for reading on the specified `device`. Can fail if memory allocation fails, or if tensor wasn't initialized yet.",48,{"inputs":[{"name":"self"},{"name":"d"}],"output":{"generics":["error"],"name":"result"}}],[11,"read_write","","Get memory for reading and writing on the specified `device`. Can fail if memory allocation fails, or if tensor wasn't initialized yet.",48,{"inputs":[{"name":"self"},{"name":"d"}],"output":{"generics":["error"],"name":"result"}}],[11,"write_only","","Get memory for writing only. This function skips synchronization and initialization checks, since contents will be overwritten anyway. By convention caller must fully initialize returned memory. Failure to do so may result in use of uninitialized data later. If caller has failed to overwrite memory, for some reason, it must call `invalidate()` to return vector to uninitialized state.",48,{"inputs":[{"name":"self"},{"name":"d"}],"output":{"generics":["error"],"name":"result"}}],[11,"drop","","Drops memory allocation on the specified device. Returns error if no memory has been allocated on this device.",48,{"inputs":[{"name":"self"},{"name":"d"}],"output":{"generics":["error"],"name":"result"}}],[11,"capacity","","Returns the number of elements for which the Tensor has been allocated.",48,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"desc","","Returns the descriptor of the Tensor.",48,{"inputs":[{"name":"self"}],"output":{"name":"tensordesc"}}],[11,"mem_size","","Returns the allocated Memory size in bytes.",48,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[11,"fmt","","",44,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",44,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"eq","","",44,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"ne","","",44,{"inputs":[{"name":"self"},{"name":"error"}],"output":{"name":"bool"}}],[11,"fmt","","",44,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",44,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",44,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"from","","",44,{"inputs":[{"name":"deviceerror"}],"output":{"name":"error"}}],[0,"operation","coaster","Provides the generic functionality for backend-agnostic operations.",null,null],[8,"IOperation","coaster::operation","Defines the functionality of an operation.",null,null],[0,"binary","coaster","Provides the generic functionality for a backend-specific implementation of a [library][libraries]. [libraries]: ../libraries/index.html",null,null],[8,"IBinary","coaster::binary","Defines the functionality for turning a library into backend-specific, executable operations.",null,null],[0,"error","coaster","Defines the general set of error types in Coaster.",null,null],[4,"Error","coaster::error","Defines the set of available Coaster error types.",null,null],[13,"Framework","","Failure related to the Framework implementation.",49,null],[13,"Tensor","","Failure related to the Tensor.",49,null],[13,"Plugin","","Failure at Plugin Operation.",49,null],[13,"Device","","Failure related to a Device.",49,null],[11,"fmt","","",49,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",49,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",49,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",49,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[0,"plugin","coaster","Provides helpers for explicit implementations of Backend [Operations][operation]. [operation]: ../operation/index.html",null,null],[8,"Float","coaster::plugin","",null,null],[10,"nan","","Returns the `NaN` value.",50,{"inputs":[],"output":{"name":"self"}}],[10,"infinity","","Returns the infinite value.",50,{"inputs":[],"output":{"name":"self"}}],[10,"neg_infinity","","Returns the negative infinite value.",50,{"inputs":[],"output":{"name":"self"}}],[10,"neg_zero","","Returns `-0.0`.",50,{"inputs":[],"output":{"name":"self"}}],[10,"min_value","","Returns the smallest finite value that this type can represent.",50,{"inputs":[],"output":{"name":"self"}}],[10,"min_positive_value","","Returns the smallest positive, normalized value that this type can represent.",50,{"inputs":[],"output":{"name":"self"}}],[11,"epsilon","","Returns epsilon, a small positive value.",50,{"inputs":[],"output":{"name":"self"}}],[10,"max_value","","Returns the largest finite value that this type can represent.",50,{"inputs":[],"output":{"name":"self"}}],[10,"is_nan","","Returns `true` if this value is `NaN` and false otherwise.",50,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_infinite","","Returns `true` if this value is positive infinity or negative infinity and false otherwise.",50,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_finite","","Returns `true` if this number is neither infinite nor `NaN`.",50,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_normal","","Returns `true` if the number is neither zero, infinite, [subnormal][subnormal], or `NaN`.",50,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"classify","","Returns the floating point category of the number. If only one property is going to be tested, it is generally faster to use the specific predicate instead.",50,{"inputs":[{"name":"self"}],"output":{"name":"fpcategory"}}],[10,"floor","","Returns the largest integer less than or equal to a number.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"ceil","","Returns the smallest integer greater than or equal to a number.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"round","","Returns the nearest integer to a number. Round half-way cases away from `0.0`.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"trunc","","Return the integer part of a number.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"fract","","Returns the fractional part of a number.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"abs","","Computes the absolute value of `self`. Returns `Float::nan()` if the number is `Float::nan()`.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"signum","","Returns a number that represents the sign of `self`.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"is_sign_positive","","Returns `true` if `self` is positive, including `+0.0`, `Float::infinity()`, and with newer versions of Rust `f64::NAN`.",50,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"is_sign_negative","","Returns `true` if `self` is negative, including `-0.0`, `Float::neg_infinity()`, and with newer versions of Rust `-f64::NAN`.",50,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"mul_add","","Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This produces a more accurate result with better performance than a separate multiplication operation followed by an add.",50,{"inputs":[{"name":"self"},{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"recip","","Take the reciprocal (inverse) of a number, `1/x`.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"powi","","Raise a number to an integer power.",50,{"inputs":[{"name":"self"},{"name":"i32"}],"output":{"name":"self"}}],[10,"powf","","Raise a number to a floating point power.",50,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"sqrt","","Take the square root of a number.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"exp","","Returns `e^(self)`, (the exponential function).",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"exp2","","Returns `2^(self)`.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"ln","","Returns the natural logarithm of the number.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"log","","Returns the logarithm of the number with respect to an arbitrary base.",50,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"log2","","Returns the base 2 logarithm of the number.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"log10","","Returns the base 10 logarithm of the number.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"to_degrees","","Converts radians to degrees.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"to_radians","","Converts degrees to radians.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"max","","Returns the maximum of the two numbers.",50,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"min","","Returns the minimum of the two numbers.",50,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"abs_sub","","The positive difference of two numbers.",50,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"cbrt","","Take the cubic root of a number.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"hypot","","Calculate the length of the hypotenuse of a right-angle triangle given legs of length `x` and `y`.",50,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"sin","","Computes the sine of a number (in radians).",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"cos","","Computes the cosine of a number (in radians).",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"tan","","Computes the tangent of a number (in radians).",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"asin","","Computes the arcsine of a number. Return value is in radians in the range [-pi/2, pi/2] or NaN if the number is outside the range [-1, 1].",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"acos","","Computes the arccosine of a number. Return value is in radians in the range [0, pi] or NaN if the number is outside the range [-1, 1].",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"atan","","Computes the arctangent of a number. Return value is in radians in the range [-pi/2, pi/2];",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"atan2","","Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).",50,{"inputs":[{"name":"self"},{"name":"self"}],"output":{"name":"self"}}],[10,"sin_cos","","Simultaneously computes the sine and cosine of the number, `x`. Returns `(sin(x), cos(x))`.",50,null],[10,"exp_m1","","Returns `e^(self) - 1` in a way that is accurate even if the number is close to zero.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"ln_1p","","Returns `ln(1+n)` (natural logarithm) more accurately than if the operations were performed separately.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"sinh","","Hyperbolic sine function.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"cosh","","Hyperbolic cosine function.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"tanh","","Hyperbolic tangent function.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"asinh","","Inverse hyperbolic sine function.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"acosh","","Inverse hyperbolic cosine function.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"atanh","","Inverse hyperbolic tangent function.",50,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[10,"integer_decode","","Returns the mantissa, base 2 exponent, and sign as integers, respectively. The original number can be recovered by `sign * mantissa * 2 ^ exponent`. The floating point encoding is documented in the [Reference][floating-point].",50,null],[4,"Error","","Defines a high-level Plugin Error.",null,null],[13,"SharedTensor","","Failure related to `SharedTensor`: use of uninitialized memory, synchronization error or memory allocation failure.",51,null],[13,"Operation","","Failure at the execution of the Operation.",51,null],[13,"Plugin","","Failure at the Plugin.",51,null],[0,"numeric_helpers","","Describes numeric types and traits for a Plugin.",null,null],[11,"fmt","","",51,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",51,{"inputs":[{"name":"self"}],"output":{"name":"error"}}],[11,"fmt","","",51,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",51,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",51,{"inputs":[{"name":"self"}],"output":{"generics":["error"],"name":"option"}}],[11,"from","coaster::error","",49,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","coaster::plugin","",51,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[0,"prelude","coaster","A module meant to be glob imported when using Coaster.",null,null],[11,"from","coaster::error","",49,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"from","","",49,{"inputs":[{"name":"error"}],"output":{"name":"error"}}]],"paths":[[8,"IBackend"],[3,"Backend"],[3,"BackendConfig"],[4,"Error"],[8,"IDevice"],[8,"MemorySync"],[4,"HardwareType"],[8,"IHardware"],[4,"Error"],[8,"IFramework"],[4,"Error"],[3,"Cpu"],[3,"FlatBox"],[3,"Hardware"],[3,"Function"],[3,"Binary"],[3,"Native"],[4,"Error"],[3,"Version"],[3,"Device"],[3,"DeviceInfo"],[3,"Platform"],[4,"ContextProperties"],[4,"ContextInfoQuery"],[4,"ContextInfo"],[3,"Context"],[3,"Memory"],[3,"MemoryFlags"],[3,"Queue"],[3,"QueueFlags"],[3,"Event"],[3,"Kernel"],[3,"Program"],[3,"API"],[3,"OpenCL"],[4,"DriverError"],[3,"Device"],[3,"DeviceInfo"],[3,"Context"],[3,"Function"],[3,"Memory"],[3,"Module"],[3,"Driver"],[3,"Cuda"],[4,"Error"],[8,"ITensorDesc"],[8,"IntoTensorDesc"],[6,"TensorDesc"],[3,"SharedTensor"],[4,"Error"],[8,"Float"],[4,"Error"]]};
initSearch(searchIndex);
